- front: 'Binary Search'
  back: |
    def binary_search(arr, target):
        l, r = 0, len(arr) - 1
        
        while l <= r:
            m = l + (r - l) // 2
            
            if arr[m] > target:
                r = m - 1
            elif arr[m] < target:
                l = m + 1
            else:
                return m
        
        return -1

- front: 'Trie'
  back: |
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.final_node = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()

        def insert(self, word):
            ptr = self.root
            for letter in word:
                if letter not in ptr.children:
                    ptr.children[letter] = TrieNode()
                ptr = ptr.children[letter]
            ptr.final_node = True

        def search(self, word) -> bool:
            ptr = self.root
            for letter in word:
                if letter not in ptr.children:
                    return False
                ptr = ptr.children[letter]
            return ptr.final_node

        def starts_with(self, prefix) -> bool:
            ptr = self.root
            for letter in prefix:
                if letter not in ptr.children:
                    return False
                ptr = ptr.children[letter]
            return True

- front: 'Singly-Linked List'
  back: |
    class ListNode:
        def __init__(self, val = 0, next = None):
            self.val = val
            self.next = next

    class SinglyLinkedList:
        def reverse_list(self, head) -> ListNode:
            l = None 
            m = head
            r = None

            while m:
                r = m.next
                m.next = l
                l = m
                m = r
            
            return l

        def detect_cycle(self, head) -> bool:
            sptr = head  # Slow pointer
            fptr = head  # Fast pointer
            
            while fptr and fptr.next:
                sptr = sptr.next
                fptr = fptr.next.next
                if sptr == fptr:
                    return True
            
            return False

- front: 'Breadth First Search (Graph)'
  back: |
    from collections import deque

    def bfs_graph(graph, start_vertex):
        visited = set()
        queue = deque([start_vertex])

        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                print(vertex)
                visited.add(vertex)
                queue.extend(graph.get(vertex, []))

- front: 'Depth First Search: Iterative (Graph)'
  back: |
    def dfs_iterative(graph, start_vertex):
        visited = set()
        stack = [start_vertex]

        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                print(vertex)
                visited.add(vertex)
                stack.extend(graph.get(vertex, []))

- front: 'Depth First Search: Recursive (Graph)'
  back: |
    def dfs_recursive(graph, start_vertex, visited = None):
        if visited is None:
            visited = set()
        visited.add(start_vertex)
        print(start_vertex)

        for neighbor in graph.get(start_vertex, []):
            if neighbor not in visited:
                dfs_recursive(graph, neighbor, visited)

- front: 'Dijkstra’s Algorithm (Shortest Path)'
  back: |
    import heapq

    def dijkstra(graph, start_vertex):
        heap = [(0, start_vertex)]
        distances = {vertex: float('inf') for vertex in graph}
        distances[start_vertex] = 0

        while heap:
            curr_dist, vertex = heapq.heappop(heap)
            if curr_dist > distances[vertex]:
                continue
            for neighbor, weight in graph[vertex]:
                distance = curr_dist + weight
                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    heapq.heappush(heap, (distance, neighbor))

        return distances

- front: 'Kruskal’s Algorithm (Minimum Spanning Tree)'
  back: |
    class UnionFind:
        def __init__(self, size):
            self.parent = list(range(size))
            self.rank = [1] * size

        def find(self, node):
            if self.parent[node] != node:
                self.parent[node] = self.find(self.parent[node])
            return self.parent[node]

        def union(self, u, v):
            root1, root2 = self.find(u), self.find(v)
            if root1 != root2:
                if self.rank[root1] > self.rank[root2]:
                    self.parent[root2] = root1
                elif self.rank[root1] < self.rank[root2]:
                    self.parent[root1] = root2
                else:
                    self.parent[root2] = root1
                    self.rank[root1] += 1

    def kruskal(graph, num_nodes):
        edges = sorted(graph, key = lambda edge: edge[2])  # Sort by weight
        uf = UnionFind(num_nodes)
        mst = []

        for u, v, weight in edges:
            if uf.find(u) != uf.find(v):
                uf.union(u, v)
                mst.append((u, v, weight))

        return mst

- front: 'Heap Sort'
  back: |
    import heapq

    def heap_sort(arr):
        heapq.heapify(arr)
        return [heapq.heappop(arr) for _ in range(len(arr))]

- front: 'Topological Sorting (Kahn’s Algorithm)'
  back: |
    from collections import deque

    def topological_sort(graph):
        in_degree = {node: 0 for node in graph}
        for node in graph:
            for neighbor in graph[node]:
                in_degree[neighbor] += 1

        queue = deque([node for node in in_degree if in_degree[node] == 0])
        result = []

        while queue:
            node = queue.popleft()
            result.append(node)
            for neighbor in graph[node]:
                in_degree[neighbor] -= 1
                if in_degree[neighbor] == 0:
                    queue.append(neighbor)

        return result if len(result) == len(graph) else []  # Return empty if cycle exists

- front: 'Merge Sort'
  back: |
    def merge_sort(arr):
        if len(arr) <= 1:
            return arr
        mid = len(arr) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        return sorted(left + right)

- front: 'Quicksort'
  back: |
    def quicksort(arr):
        if len(arr) <= 1:
            return arr

        pivot = arr[len(arr) // 2]
        left = [x for x in arr if x < pivot]
        middle = [x for x in arr if x == pivot]
        right = [x for x in arr if x > pivot]
        return quicksort(left) + middle + quicksort(right)
