- front: 'Binary Search'
  back: |
    def binary_search(arr, target):
        l, r = 0, len(arr) - 1
        
        while l <= r:
            m = l + (r - l) // 2
            
            if arr[m] > target:
                r = m - 1
            elif arr[m] < target:
                l = m + 1
            else:
                return m
        
        return -1

- front: 'Trie'
  back: |
    class TrieNode:
        def __init__(self):
            self.children = {}
            self.final_node = False

    class Trie:
        def __init__(self):
            self.root = TrieNode()

        def insert(self, word: str):
            ptr = self.root

            for letter in word:
                if letter not in ptr.children:
                    ptr.children[letter] = TrieNode()
                ptr = ptr.children[letter]
            ptr.final_node = True

        def search(self, word: str) -> bool:
            ptr = self.root

            for letter in word:
                if letter not in ptr.children:
                    return False
                ptr = ptr.children[letter]
            
            return ptr.final_node

        def starts_with(self, prefix: str) -> bool:
            ptr = self.root

            for letter in prefix:
                if letter not in ptr.children:
                    return False
                ptr = ptr.children[letter]
            
            return True

- front: 'Singly-Linked List'
  back: |
    class ListNode:
        def __init__(self, val=0, next=None):
            self.val = val
            self.next = next

    class SinglyLinkedList:

        def reverseList(self, head: [ListNode]) -> [ListNode]:
            l = None 
            m = head
            r = None

            while m:
                r = m.next
                m.next = l
                l = m
                m = r
            
            return head

        def mergeTwoLists(self, list1: [ListNode], list2: [ListNode]) -> [ListNode]:
            head = None
            ptr = head

            while list1 or list2:
                if list1 and list2 and list1.val <= list2.val or list1 and not list2:
                    node = ListNode(list1.val, None)
                    list1 = list1.next
                elif list1 and list2 or not list1 and list2:
                    node = ListNode(list2.val, None)
                    list2 = list2.next
                if not ptr:
                    ptr = node
                    head = ptr
                else:
                    ptr.next = node
                    ptr = ptr.next

            return head

          def hasCycle(self, head: Optional[ListNode]) -> bool:

            ssp = head # Single step pointer
            dsp = head # Double step pointer
            
            while dsp and dsp.next:
                ssp = ssp.next
                dsp = dsp.next.next
            
            if ssp == dsp:
                return True
            
            return False

        def removeNthFromEnd(self, head: [ListNode], n: int) -> [ListNode]:
        
            ptr = head
            len = 0

            while ptr:
                len += 1
                ptr = ptr.next
            
            ptr = head
            i = 0

            if len == n:
                return head.next

            while ptr and i < len - n - 1:
                ptr = ptr.next
                i += 1
            
            if ptr.next:
                ptr.next = ptr.next.next
            else:
                ptr.next = None
        
            return head
        
        def mergeKLists(self, lists: [[ListNode]]) -> [ListNode]:
            heap = []
            for node_list in lists:
                while node_list:
                    heappush(heap, node_list.val)
                    node_list = node_list.next
            
            head = None
            if heap:
                head = ptr = ListNode(heappop(heap), None)

            while heap:
                ptr.next = ListNode(heappop(heap), None)
                ptr = ptr.next

            return head

- front: 'Breadth First Search (Graph)'
  back: |
    from collections import deque

    def bfs_graph(graph, start_vertex):
        visited = set()
        queue = deque([start_vertex])

        while queue:
            vertex = queue.popleft()
            if vertex not in visited:
                print(vertex, end=' ')
                visited.add(vertex)
                queue.append(graph.get(vertex, []))

- front: 'Breadth First Traversal (Tree: Level Order)'
  back: |
    from collections import deque

    class TreeNode:
        def __init__(self, value):
            self.value = value
            self.left = None
            self.right = None

    def bfs_tree(root):
        if not root:
            return
        queue = deque([root])
        while queue:
            node = queue.popleft()
            print(node.value, end=' ')
            if node.left:
                queue.append(node.left)
            if node.right:
                queue.append(node.right)

- front: 'Depth First Search: Iterative (Graph)'
  back: |
    def dfs_iterative(graph, start_vertex):
        visited = set()
        stack = [start_vertex]

        while stack:
            vertex = stack.pop()
            if vertex not in visited:
                print(vertex, end=' ')
                visited.add(vertex)
                stack.append(graph.get(vertex, []))

- front: 'Depth First Search: Recursive (Graph)'
  back: |
    def dfs_recursive(graph, node, visited=None):
        if visited is None:
            visited = set()
        visited.add(node)
        print(node, end' ')

        for neighbor in graph.get(node, []):
            if neighbor not in visited:
                dfs_recursive(graph, neighbor, visited)

- front: 'Depth First Traversal (Tree: Preorder, Inorder, Postorder)'
  back: |
    def preorder(root):
        if root:
            print(root.value, end=' ')
            preorder(root.left)
            preorder(root.right)

    def inorder(root):
        if root:
            inorder(root.left)
            print(root.value, end=' ')
            inorder(root.right)

    def postorder(root):
        if root:
            postorder(root.left)
            postorder(root.right)
            print(root.value, end=' ')

- front: 'Insertion Sort'
  back: |
    def insertion_sort(arr):
        for i in range(1, len(arr)):
            key = arr[i]
            j = i - 1
            while j >= 0 and arr[j] > key:
                arr[j + 1] = arr[j]
                j -= 1
            arr[j + 1] = key
        return arr

- front: 'Merge Sort'
  back: |
    def merge_sort(nums):
        if len(nums) <= 1:
            return arr
        mid = len(nums) // 2
        left = merge_sort(arr[:mid])
        right = merge_sort(arr[mid:])
        return sorted(left + right)

- front: 'Quicksort'
  back: |
    def quicksort(nums):
        if len(nums) &lt;= 1:
            return nums

        pivot = arr[len(nums) // 2]
        left = [x for x in nums if x &lt; pivot]
        middle = [x for x in nums if x == pivot]
        right = [x for x in nums if x &gt; pivot]
        return quicksort(left) + middle + quicksort(right)
